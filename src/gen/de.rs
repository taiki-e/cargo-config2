// This file is @generated by cargo-config2-internal-codegen
// (gen_de function at tools/codegen/src/main.rs).
// It is not intended for manual editing.

#![cfg_attr(rustfmt, rustfmt::skip)]

use std::path::Path;
use crate::{
    lazy::{FromConfigValue, ConfigValue},
    merge::Merge, value::{SetPath, Value},
    Result,
};
impl Merge for crate::de::Config {
    fn merge(&mut self, from: Self, force: bool) -> Result<()> {
        self.alias.merge(from.alias, force)?;
        self.build.merge(from.build, force)?;
        self.doc.merge(from.doc, force)?;
        self.env.merge(from.env, force)?;
        self.future_incompat_report.merge(from.future_incompat_report, force)?;
        self.net.merge(from.net, force)?;
        self.target.merge(from.target, force)?;
        self.term.merge(from.term, force)?;
        Ok(())
    }
}
impl SetPath for crate::de::Config {
    fn set_path(&mut self, path: &Path) {
        self.alias.set_path(path);
        self.build.set_path(path);
        self.doc.set_path(path);
        self.env.set_path(path);
        self.future_incompat_report.set_path(path);
        self.net.set_path(path);
        self.target.set_path(path);
        self.term.set_path(path);
    }
}
impl Merge for crate::de::BuildConfig {
    fn merge(&mut self, from: Self, force: bool) -> Result<()> {
        self.jobs.merge(from.jobs, force)?;
        self.rustc.merge(from.rustc, force)?;
        self.rustc_wrapper.merge(from.rustc_wrapper, force)?;
        self.rustc_workspace_wrapper.merge(from.rustc_workspace_wrapper, force)?;
        self.rustdoc.merge(from.rustdoc, force)?;
        self.target.merge(from.target, force)?;
        self.target_dir.merge(from.target_dir, force)?;
        self.rustflags.merge(from.rustflags, force)?;
        self.rustdocflags.merge(from.rustdocflags, force)?;
        self.incremental.merge(from.incremental, force)?;
        self.dep_info_basedir.merge(from.dep_info_basedir, force)?;
        Ok(())
    }
}
impl SetPath for crate::de::BuildConfig {
    fn set_path(&mut self, path: &Path) {
        self.jobs.set_path(path);
        self.rustc.set_path(path);
        self.rustc_wrapper.set_path(path);
        self.rustc_workspace_wrapper.set_path(path);
        self.rustdoc.set_path(path);
        self.target.set_path(path);
        self.target_dir.set_path(path);
        self.rustflags.set_path(path);
        self.rustdocflags.set_path(path);
        self.incremental.set_path(path);
        self.dep_info_basedir.set_path(path);
    }
}
impl FromConfigValue for crate::de::BuildConfig {
    fn from_config_value(value: &ConfigValue, current_key: &str) -> Result<Self> {
        let mut jobs = None;
        let mut rustc = None;
        let mut rustc_wrapper = None;
        let mut rustc_workspace_wrapper = None;
        let mut rustdoc = None;
        let mut target = None;
        let mut target_dir = None;
        let mut rustflags = None;
        let mut rustdocflags = None;
        let mut incremental = None;
        let mut dep_info_basedir = None;
        for (k, v) in value.table(&[current_key])?.0 {
            match k.as_str() {
                "jobs" => {
                    let (val, def) = v.i64(&[current_key, "jobs"])?;
                    jobs = Some(Value {
                        val: val.try_into()?,
                        definition: Some(def.clone()),
                    });
                }
                "rustc" => {
                    let (val, def) = v.string(&[current_key, "rustc"])?;
                    rustc = Some(Value {
                        val: val.to_owned(),
                        definition: Some(def.clone()),
                    });
                }
                "rustc-wrapper" => {
                    let (val, def) = v.string(&[current_key, "rustc-wrapper"])?;
                    rustc_wrapper = Some(Value {
                        val: val.to_owned(),
                        definition: Some(def.clone()),
                    });
                }
                "rustc-workspace-wrapper" => {
                    let (val, def) = v
                        .string(&[current_key, "rustc-workspace-wrapper"])?;
                    rustc_workspace_wrapper = Some(Value {
                        val: val.to_owned(),
                        definition: Some(def.clone()),
                    });
                }
                "rustdoc" => {
                    let (val, def) = v.string(&[current_key, "rustdoc"])?;
                    rustdoc = Some(Value {
                        val: val.to_owned(),
                        definition: Some(def.clone()),
                    });
                }
                "target" => {
                    target = Some(
                        crate::de::StringOrArray::from_config_value(v, "build.target")?,
                    );
                }
                "target-dir" => {
                    let (val, def) = v.string(&[current_key, "target-dir"])?;
                    target_dir = Some(Value {
                        val: val.to_owned(),
                        definition: Some(def.clone()),
                    });
                }
                "rustflags" => {
                    rustflags = Some(
                        crate::de::Rustflags::from_config_value(v, "build.rustflags")?,
                    );
                }
                "rustdocflags" => {
                    rustdocflags = Some(
                        crate::de::Rustflags::from_config_value(v, "build.rustdocflags")?,
                    );
                }
                "incremental" => {
                    let (val, def) = v.boolean(&[current_key, "incremental"])?;
                    incremental = Some(Value {
                        val,
                        definition: Some(def.clone()),
                    });
                }
                "dep-info-basedir" => {
                    let (val, def) = v.string(&[current_key, "dep-info-basedir"])?;
                    dep_info_basedir = Some(Value {
                        val: val.to_owned(),
                        definition: Some(def.clone()),
                    });
                }
                _ => {}
            }
        }
        Ok(Self {
            jobs,
            rustc,
            rustc_wrapper,
            rustc_workspace_wrapper,
            rustdoc,
            target,
            target_dir,
            rustflags,
            rustdocflags,
            incremental,
            dep_info_basedir,
            override_target_rustflags: Default::default(),
        })
    }
}
impl Merge for crate::de::TargetConfig {
    fn merge(&mut self, from: Self, force: bool) -> Result<()> {
        self.linker.merge(from.linker, force)?;
        self.runner.merge(from.runner, force)?;
        self.rustflags.merge(from.rustflags, force)?;
        Ok(())
    }
}
impl SetPath for crate::de::TargetConfig {
    fn set_path(&mut self, path: &Path) {
        self.linker.set_path(path);
        self.runner.set_path(path);
        self.rustflags.set_path(path);
    }
}
impl FromConfigValue for crate::de::TargetConfig {
    fn from_config_value(value: &ConfigValue, current_key: &str) -> Result<Self> {
        let mut linker = None;
        let mut runner = None;
        let mut rustflags = None;
        for (k, v) in value.table(&[current_key])?.0 {
            match k.as_str() {
                "linker" => {
                    let (val, def) = v.string(&[current_key, "linker"])?;
                    linker = Some(Value {
                        val: val.to_owned(),
                        definition: Some(def.clone()),
                    });
                }
                "runner" => {
                    runner = Some(
                        crate::de::PathAndArgs::from_config_value(v, "runner")?,
                    );
                }
                "rustflags" => {
                    rustflags = Some(
                        crate::de::Rustflags::from_config_value(v, "rustflags")?,
                    );
                }
                _ => {}
            }
        }
        Ok(Self { linker, runner, rustflags })
    }
}
impl Merge for crate::de::DocConfig {
    fn merge(&mut self, from: Self, force: bool) -> Result<()> {
        self.browser.merge(from.browser, force)?;
        Ok(())
    }
}
impl SetPath for crate::de::DocConfig {
    fn set_path(&mut self, path: &Path) {
        self.browser.set_path(path);
    }
}
impl FromConfigValue for crate::de::DocConfig {
    fn from_config_value(value: &ConfigValue, current_key: &str) -> Result<Self> {
        let mut browser = None;
        for (k, v) in value.table(&[current_key])?.0 {
            match k.as_str() {
                "browser" => {
                    browser = Some(
                        crate::de::PathAndArgs::from_config_value(v, "doc.browser")?,
                    );
                }
                _ => {}
            }
        }
        Ok(Self { browser })
    }
}
impl SetPath for crate::de::EnvConfigValue {
    fn set_path(&mut self, path: &Path) {
        match self {
            Self::Value(v) => {
                v.set_path(path);
            }
            Self::Table { value, force, relative } => {
                value.set_path(path);
                force.set_path(path);
                relative.set_path(path);
            }
        }
    }
}
impl Merge for crate::de::FutureIncompatReportConfig {
    fn merge(&mut self, from: Self, force: bool) -> Result<()> {
        self.frequency.merge(from.frequency, force)?;
        Ok(())
    }
}
impl SetPath for crate::de::FutureIncompatReportConfig {
    fn set_path(&mut self, path: &Path) {
        self.frequency.set_path(path);
    }
}
impl FromConfigValue for crate::de::FutureIncompatReportConfig {
    fn from_config_value(value: &ConfigValue, current_key: &str) -> Result<Self> {
        let mut frequency = None;
        for (k, v) in value.table(&[current_key])?.0 {
            match k.as_str() {
                "frequency" => {
                    let (val, def) = v.string(&[current_key, "frequency"])?;
                    frequency = Some(Value {
                        val: val.parse::<crate::Frequency>()?,
                        definition: Some(def.clone()),
                    });
                }
                _ => {}
            }
        }
        Ok(Self { frequency })
    }
}
impl Merge for crate::de::NetConfig {
    fn merge(&mut self, from: Self, force: bool) -> Result<()> {
        self.retry.merge(from.retry, force)?;
        self.git_fetch_with_cli.merge(from.git_fetch_with_cli, force)?;
        self.offline.merge(from.offline, force)?;
        Ok(())
    }
}
impl SetPath for crate::de::NetConfig {
    fn set_path(&mut self, path: &Path) {
        self.retry.set_path(path);
        self.git_fetch_with_cli.set_path(path);
        self.offline.set_path(path);
    }
}
impl FromConfigValue for crate::de::NetConfig {
    fn from_config_value(value: &ConfigValue, current_key: &str) -> Result<Self> {
        let mut retry = None;
        let mut git_fetch_with_cli = None;
        let mut offline = None;
        for (k, v) in value.table(&[current_key])?.0 {
            match k.as_str() {
                "retry" => {
                    let (val, def) = v.i64(&[current_key, "retry"])?;
                    retry = Some(Value {
                        val: val.try_into()?,
                        definition: Some(def.clone()),
                    });
                }
                "git-fetch-with-cli" => {
                    let (val, def) = v.boolean(&[current_key, "git-fetch-with-cli"])?;
                    git_fetch_with_cli = Some(Value {
                        val,
                        definition: Some(def.clone()),
                    });
                }
                "offline" => {
                    let (val, def) = v.boolean(&[current_key, "offline"])?;
                    offline = Some(Value {
                        val,
                        definition: Some(def.clone()),
                    });
                }
                _ => {}
            }
        }
        Ok(Self {
            retry,
            git_fetch_with_cli,
            offline,
        })
    }
}
impl Merge for crate::de::TermConfig {
    fn merge(&mut self, from: Self, force: bool) -> Result<()> {
        self.quiet.merge(from.quiet, force)?;
        self.verbose.merge(from.verbose, force)?;
        self.color.merge(from.color, force)?;
        self.progress.merge(from.progress, force)?;
        Ok(())
    }
}
impl SetPath for crate::de::TermConfig {
    fn set_path(&mut self, path: &Path) {
        self.quiet.set_path(path);
        self.verbose.set_path(path);
        self.color.set_path(path);
        self.progress.set_path(path);
    }
}
impl FromConfigValue for crate::de::TermConfig {
    fn from_config_value(value: &ConfigValue, current_key: &str) -> Result<Self> {
        let mut quiet = None;
        let mut verbose = None;
        let mut color = None;
        let mut progress = None;
        for (k, v) in value.table(&[current_key])?.0 {
            match k.as_str() {
                "quiet" => {
                    let (val, def) = v.boolean(&[current_key, "quiet"])?;
                    quiet = Some(Value {
                        val,
                        definition: Some(def.clone()),
                    });
                }
                "verbose" => {
                    let (val, def) = v.boolean(&[current_key, "verbose"])?;
                    verbose = Some(Value {
                        val,
                        definition: Some(def.clone()),
                    });
                }
                "color" => {
                    let (val, def) = v.string(&[current_key, "color"])?;
                    color = Some(Value {
                        val: val.parse::<crate::Color>()?,
                        definition: Some(def.clone()),
                    });
                }
                "progress" => {
                    progress = Some(
                        crate::de::TermProgress::from_config_value(v, "term.progress")?,
                    );
                }
                _ => {}
            }
        }
        Ok(Self {
            quiet,
            verbose,
            color,
            progress: progress.unwrap_or_default(),
        })
    }
}
impl Merge for crate::de::TermProgress {
    fn merge(&mut self, from: Self, force: bool) -> Result<()> {
        self.when.merge(from.when, force)?;
        self.width.merge(from.width, force)?;
        Ok(())
    }
}
impl SetPath for crate::de::TermProgress {
    fn set_path(&mut self, path: &Path) {
        self.when.set_path(path);
        self.width.set_path(path);
    }
}
impl FromConfigValue for crate::de::TermProgress {
    fn from_config_value(value: &ConfigValue, current_key: &str) -> Result<Self> {
        let mut when = None;
        let mut width = None;
        for (k, v) in value.table(&[current_key])?.0 {
            match k.as_str() {
                "when" => {
                    let (val, def) = v.string(&[current_key, "when"])?;
                    when = Some(Value {
                        val: val.parse::<crate::When>()?,
                        definition: Some(def.clone()),
                    });
                }
                "width" => {
                    let (val, def) = v.i64(&[current_key, "width"])?;
                    width = Some(Value {
                        val: val.try_into()?,
                        definition: Some(def.clone()),
                    });
                }
                _ => {}
            }
        }
        Ok(Self { when, width })
    }
}
impl SetPath for crate::de::Rustflags {
    fn set_path(&mut self, path: &Path) {
        self.flags.set_path(path);
    }
}
impl SetPath for crate::de::ConfigRelativePath {
    fn set_path(&mut self, path: &Path) {
        self.0.set_path(path);
    }
}
impl SetPath for crate::de::PathAndArgs {
    fn set_path(&mut self, path: &Path) {
        self.path.set_path(path);
        self.args.set_path(path);
    }
}
impl SetPath for crate::de::StringList {
    fn set_path(&mut self, path: &Path) {
        self.list.set_path(path);
    }
}
impl SetPath for crate::de::StringOrArray {
    fn set_path(&mut self, path: &Path) {
        match self {
            Self::String(v) => {
                v.set_path(path);
            }
            Self::Array(v) => {
                v.set_path(path);
            }
        }
    }
}
