#![warn(rust_2018_idioms, single_use_lifetimes)]

use std::{
    collections::BTreeSet,
    path::{Path, PathBuf},
};

use anyhow::Result;
use fs_err as fs;
use heck::ToKebabCase;
use proc_macro2::TokenStream;
use quote::{format_ident, quote};
use syn::{
    visit_mut::{self, VisitMut},
    *,
};

fn main() -> Result<()> {
    gen_assert_impl()?;
    gen_de()?;
    gen_is_none()?;
    Ok(())
}

fn workspace_root() -> PathBuf {
    let mut dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    dir.pop(); // codegen
    dir.pop(); // tools
    dir
}

#[track_caller]
fn header(function_name: &str) -> String {
    // rust-analyzer does not respect outer attribute (#[rustfmt::skip]) on
    // a module without a body. So use inner attribute under cfg(rustfmt).
    format!(
        "// This file is @generated by {bin_name}
// ({function_name} function at {file}).
// It is not intended for manual editing.\n
#![cfg_attr(rustfmt, rustfmt::skip)]\n
",
        bin_name = env!("CARGO_BIN_NAME"),
        file = std::panic::Location::caller().file()
    )
}

#[track_caller]
fn write(function_name: &str, path: &Path, contents: TokenStream) -> Result<()> {
    let mut out = header(function_name).into_bytes();
    out.extend_from_slice(
        prettyplease::unparse(
            &syn::parse2(contents.clone())
                .unwrap_or_else(|e| panic!("{e} in:\n---\n{contents}\n---")),
        )
        .as_bytes(),
    );
    if path.is_file() && fs::read(path)? == out {
        return Ok(());
    }
    fs::write(path, out)?;
    Ok(())
}

fn gen_de() -> Result<()> {
    const FILES: &[&str] = &["src/de.rs"];
    // TODO: check if this list is outdated
    const MERGE_EXCLUDE: &[&str] =
        &["Rustflags", "ResolveContext", "EnvConfigValue", "StringList", "PathAndArgs"];
    const SET_PATH_EXCLUDE: &[&str] = &[];
    const FROM_CONFIG_VALUE_EXCLUDE: &[&str] =
        &["Rustflags", "ResolveContext", "EnvConfigValue", "StringList", "PathAndArgs", "Config"];

    let workspace_root = &workspace_root();

    let mut tokens = quote! {
        use std::path::Path;
        use crate::{
            lazy::{FromConfigValue, ConfigValue},
            merge::Merge,
            value::{SetPath, Value},
            Result,
        };
    };

    for &f in FILES {
        let s = fs::read_to_string(workspace_root.join(f))?;
        let mut ast = syn::parse_file(&s)?;

        let module = if f.ends_with("lib.rs") {
            vec![]
        } else {
            let name = format_ident!("{}", Path::new(f).file_stem().unwrap().to_string_lossy());
            vec![name.into()]
        };

        ItemVisitor::new(module, |item, module| {
            // impl Merge
            match item {
                syn::Item::Struct(syn::ItemStruct { vis, ident, fields, .. })
                    if matches!(vis, syn::Visibility::Public(..))
                        && matches!(fields, syn::Fields::Named(..))
                        && !MERGE_EXCLUDE.iter().any(|&e| ident == e) =>
                {
                    let fields = fields
                        .iter()
                        .filter(|f| {
                            !serde_skip(&f.attrs)
                                && f.ident.as_ref().unwrap() != "serialized_repr"
                                && f.ident.as_ref().unwrap() != "deserialized_repr"
                        })
                        .map(|syn::Field { ident, .. }| {
                            quote! { self.#ident.merge(from.#ident, force)?; }
                        });
                    tokens.extend(quote! {
                        impl Merge for crate:: #(#module::)* #ident {
                            fn merge(&mut self, from: Self, force: bool) -> Result<()> {
                                #(#fields)*
                                Ok(())
                            }
                        }
                    });
                }
                _ => {}
            }
            // impl SetPath
            match item {
                syn::Item::Struct(syn::ItemStruct { vis, ident, fields, .. })
                    if matches!(vis, syn::Visibility::Public(..))
                        && !SET_PATH_EXCLUDE.iter().any(|&e| ident == e) =>
                {
                    match fields {
                        Fields::Named(fields) => {
                            let fields = fields
                                .named
                                .iter()
                                .filter(|f| {
                                    !serde_skip(&f.attrs)
                                        && f.ident.as_ref().unwrap() != "serialized_repr"
                                        && f.ident.as_ref().unwrap() != "deserialized_repr"
                                })
                                .map(|syn::Field { ident, .. }| {
                                    quote! { self.#ident.set_path(path); }
                                });
                            tokens.extend(quote! {
                                impl SetPath for crate:: #(#module::)* #ident {
                                    fn set_path(&mut self, path: &Path) {
                                        #(#fields)*
                                    }
                                }
                            });
                        }
                        Fields::Unnamed(fields) => {
                            assert_eq!(fields.unnamed.len(), 1);
                            tokens.extend(quote! {
                                impl SetPath for crate:: #(#module::)* #ident {
                                    fn set_path(&mut self, path: &Path) {
                                        self.0.set_path(path);
                                    }
                                }
                            });
                        }
                        Fields::Unit => unreachable!(),
                    }
                }
                syn::Item::Enum(syn::ItemEnum { vis, ident, variants, .. })
                    if matches!(vis, syn::Visibility::Public(..))
                        && variants.iter().all(|v| !v.fields.is_empty())
                        && SET_PATH_EXCLUDE.iter().all(|&e| ident != e) =>
                {
                    let mut arms = vec![];
                    for syn::Variant { ident, fields, .. } in variants {
                        match fields {
                            Fields::Named(fields) => {
                                let pat = fields
                                    .named
                                    .iter()
                                    .filter(|f| !serde_skip(&f.attrs))
                                    .map(|syn::Field { ident, .. }| ident);
                                let calls =
                                    fields.named.iter().filter(|f| !serde_skip(&f.attrs)).map(
                                        |syn::Field { ident, .. }| {
                                            quote! { #ident.set_path(path); }
                                        },
                                    );
                                arms.push(quote! {
                                    Self::#ident { #(#pat),* } => {
                                        #(#calls)*
                                    }
                                });
                            }
                            Fields::Unnamed(fields) => {
                                assert_eq!(fields.unnamed.len(), 1);
                                arms.push(quote! {
                                    Self::#ident(v) => {
                                        v.set_path(path);
                                    }
                                });
                            }
                            Fields::Unit => unreachable!(),
                        }
                    }
                    tokens.extend(quote! {
                        impl SetPath for crate:: #(#module::)* #ident {
                            fn set_path(&mut self, path: &Path) {
                                match self {
                                    #(#arms,)*
                                }
                            }
                        }
                    });
                }
                _ => {}
            }
            // impl FromConfigValue
            match item {
                syn::Item::Struct(syn::ItemStruct { vis, ident, fields, .. })
                    if matches!(vis, syn::Visibility::Public(..))
                        && matches!(fields, syn::Fields::Named(..))
                        && !FROM_CONFIG_VALUE_EXCLUDE.iter().any(|&e| ident == e) =>
                {
                    let struct_ident = &*ident;
                    let mut result = vec![];
                    let mut init = vec![];
                    let mut arms = vec![];
                    for syn::Field { attrs, ident, ty, .. } in fields {
                        let ident = ident.as_ref().unwrap();
                        let toml_field = ident.to_string().to_kebab_case();
                        if serde_skip(attrs) {
                            result.push(quote! { #ident: Default::default() });
                            continue;
                        }
                        let current_key = || {
                            match struct_ident.to_string().as_str() {
                                "BuildConfig" => format!("build.{toml_field}"),
                                "DocConfig" => format!("doc.{toml_field}"),
                                "TermConfig" => format!("term.{toml_field}"),
                                // this config is used for both [target] and [host]
                                "TargetConfig" => toml_field.clone(),
                                _ => todo!("{struct_ident}"),
                            }
                        };
                        init.push(quote! { let mut #ident = None; });
                        let arm = (|| {
                            if let Some(ty) = is_option(ty) {
                                result.push(quote! { #ident });
                                if let Some(ty) = is_value(ty) {
                                    if let Some(ty) = ty_path(ty).and_then(|p| p.get_ident()) {
                                        let (get, convert) = match ty.to_string().as_str() {
                                            "bool" => (quote!(boolean), quote!(val)),
                                            "String" => {
                                                (quote!(string), quote!(val: val.to_owned()))
                                            }
                                            "When" | "Color" | "Frequency" => (
                                                quote!(string),
                                                quote!(val: val.parse::<crate::#ty>()?),
                                            ),
                                            "i32" | "u32" => {
                                                (quote!(i64), quote!(val: val.try_into()?))
                                            }
                                            _ => todo!(),
                                        };
                                        return quote! {
                                            #toml_field => {
                                                let (val, def) = v.#get(&[
                                                    current_key, #toml_field
                                                ])?;
                                                #ident = Some(Value {
                                                    #convert, definition: Some(def.clone())
                                                });
                                            }
                                        };
                                    }
                                    todo!();
                                } else {
                                    let current_key = current_key();
                                    quote! {
                                        #toml_field => {
                                            #ident = Some(crate:: #(#module::)*
                                                #ty::from_config_value(
                                                    v, #current_key
                                                )?
                                            );
                                        }
                                    }
                                }
                            } else {
                                result.push(quote! { #ident: #ident.unwrap_or_default() });
                                let current_key = current_key();
                                quote! {
                                    #toml_field => {
                                        #ident = Some(crate:: #(#module::)* #ty::from_config_value(
                                            v, #current_key
                                        )?);
                                    }
                                }
                            }
                        })();
                        arms.push(arm);
                    }
                    tokens.extend(quote! {
                        impl FromConfigValue for crate:: #(#module::)* #ident {
                            fn from_config_value(
                                value: &ConfigValue,
                                current_key: &str
                            ) -> Result<Self> {
                                #(#init)*
                                for (k, v) in value.table(&[current_key])?.0 {
                                    match k.as_str() {
                                        #(#arms)*
                                        _ => {}
                                    }
                                }
                                Ok(Self { #(#result),* })
                            }
                        }
                    });
                }
                _ => {}
            }
        })
        .visit_file_mut(&mut ast);
    }

    write("gen_de", &workspace_root.join("src/gen/de.rs"), tokens)?;

    Ok(())
}

fn gen_is_none() -> Result<()> {
    const FILES: &[&str] = &["src/lib.rs", "src/easy.rs", "src/de.rs"];
    // TODO: check if this list is outdated
    const EXCLUDE: &[&str] = &[
        "Config",
        "TargetConfig",
        "Rustflags",
        "ResolveContext",
        "EnvConfigValue",
        "StringList",
        "PathAndArgs",
    ];

    let workspace_root = &workspace_root();

    let mut tokens = quote! {};

    for &f in FILES {
        let s = fs::read_to_string(workspace_root.join(f))?;
        let mut ast = syn::parse_file(&s)?;

        let module = if f.ends_with("lib.rs") {
            vec![]
        } else {
            let name = format_ident!("{}", Path::new(f).file_stem().unwrap().to_string_lossy());
            vec![name.into()]
        };

        ItemVisitor::new(module, |item, module| match item {
            syn::Item::Struct(syn::ItemStruct { vis, ident, fields, .. })
                if matches!(vis, syn::Visibility::Public(..))
                    && matches!(fields, syn::Fields::Named(..))
                    && !EXCLUDE.iter().any(|&e| ident == e) =>
            {
                let fields = fields.iter().filter(|f| !serde_skip(&f.attrs)).map(
                    |syn::Field { ident, .. }| {
                        quote! { self.#ident.is_none() }
                    },
                );
                tokens.extend(quote! {
                    impl crate:: #(#module::)* #ident {
                        pub(crate) fn is_none(&self) -> bool {
                            #(#fields) &&*
                        }
                    }
                });
            }
            _ => {}
        })
        .visit_file_mut(&mut ast);
    }

    write("gen_is_none", &workspace_root.join("src/gen/is_none.rs"), tokens)?;

    Ok(())
}

fn serde_skip(attrs: &[syn::Attribute]) -> bool {
    for meta in attrs
        .iter()
        .filter(|attr| attr.path.is_ident("serde"))
        .filter_map(|attr| attr.parse_meta().ok())
    {
        if let syn::Meta::List(list) = meta {
            for repr in list.nested {
                if let syn::NestedMeta::Meta(syn::Meta::Path(p)) = repr {
                    if p.is_ident("skip") {
                        return true;
                    }
                }
            }
        }
    }
    false
}

fn gen_assert_impl() -> Result<()> {
    let workspace_root = &workspace_root();
    let out_dir = &workspace_root.join("src/gen");
    fs::create_dir_all(out_dir)?;

    let files: BTreeSet<String> = ignore::Walk::new(workspace_root.join("src"))
        .filter_map(Result::ok)
        .filter_map(|e| {
            let path = e.path();
            if !path.is_file() || path.extension() != Some("rs".as_ref()) {
                return None;
            }
            // Assertions are only needed for the library's public APIs.
            if path.ends_with("main.rs") {
                return None;
            }
            Some(path.to_string_lossy().into_owned())
        })
        .collect();

    let mut tokens = quote! {};
    for f in &files {
        let s = fs::read_to_string(f)?;
        let mut ast = syn::parse_file(&s)?;

        let module = if f.ends_with("lib.rs") {
            vec![]
        } else {
            let name = format_ident!("{}", Path::new(f).file_stem().unwrap().to_string_lossy());
            vec![name.into()]
        };

        ItemVisitor::new(module, |item, module| match item {
            syn::Item::Struct(syn::ItemStruct { vis, ident, generics, .. })
            | syn::Item::Enum(syn::ItemEnum { vis, ident, generics, .. })
            | syn::Item::Union(syn::ItemUnion { vis, ident, generics, .. })
            | syn::Item::Type(syn::ItemType { vis, ident, generics, .. })
                if matches!(vis, syn::Visibility::Public(..)) =>
            {
                // TODO: handle generics
                if generics.type_params().count() != 0 || generics.const_params().count() != 0 {
                    return;
                }

                let lt_count = generics.lifetimes().count();
                let lt = if lt_count > 0 {
                    let lt = (0..lt_count).map(|_| quote! { '_ });
                    quote! { <#(#lt),*> }
                } else {
                    quote! {}
                };
                tokens.extend(quote! {
                    assert_auto_traits::<crate:: #(#module::)* #ident #lt>();
                });
            }
            _ => {}
        })
        .visit_file_mut(&mut ast);
    }

    let out = quote! {
        const _: fn() = || {
            fn assert_auto_traits<T: ?Sized + Send + Sync + Unpin>() {}
            #tokens
        };
    };
    write("gen_assert_impl", &out_dir.join("assert_impl.rs"), out)?;

    Ok(())
}

struct ItemVisitor<F> {
    module: Vec<syn::PathSegment>,
    f: F,
}

impl<F> ItemVisitor<F>
where
    F: FnMut(&mut syn::Item, &[syn::PathSegment]),
{
    fn new(module: Vec<syn::PathSegment>, f: F) -> Self {
        Self { module, f }
    }
}

impl<F> VisitMut for ItemVisitor<F>
where
    F: FnMut(&mut syn::Item, &[syn::PathSegment]),
{
    fn visit_item_mut(&mut self, item: &mut syn::Item) {
        if let syn::Item::Mod(item) = item {
            self.module.push(item.ident.clone().into());
            visit_mut::visit_item_mod_mut(self, item);
            self.module.pop();
            return;
        }
        (self.f)(item, &self.module);
        visit_mut::visit_item_mut(self, item);
    }
}

fn ty_path(ty: &Type) -> Option<&syn::Path> {
    if let Type::Path(ty) = ty {
        return Some(&ty.path);
    }
    None
}

fn is_primitive(ty: &Type) -> Option<&Ident> {
    if let Some(path) = ty_path(ty) {
        let ty = &path.get_ident()?;
        if matches!(
            &*ty.to_string(),
            "bool"
                | "char"
                | "u8"
                | "u16"
                | "u32"
                | "u64"
                | "u128"
                | "usize"
                | "i8"
                | "i16"
                | "i32"
                | "i64"
                | "i128"
                | "isize"
                | "f32"
                | "f64"
        ) {
            return Some(ty);
        }
    }
    None
}

fn is_vec(ty: &Type) -> Option<(syn::Path, &Type)> {
    if let Some(path) = ty_path(ty) {
        if path.segments.len() == 1 && path.segments[0].ident == "Vec"
            || path.segments.len() == 3
                && (path.segments[0].ident == "std" || path.segments[0].ident == "alloc")
                && path.segments[1].ident == "vec"
                && path.segments[2].ident == "Vec"
        {
            if let PathArguments::AngleBracketed(args) = &path.segments.last().unwrap().arguments {
                if let GenericArgument::Type(t) = &args.args[0] {
                    let mut path = path.clone();
                    path.segments.last_mut().unwrap().arguments = PathArguments::None;
                    return Some((path, t));
                }
            }
        }
    }
    None
}

fn is_option(ty: &Type) -> Option<&Type> {
    if let Some(path) = ty_path(ty) {
        if path.segments.len() == 1 && path.segments[0].ident == "Option"
            || path.segments.len() == 3
                && (path.segments[0].ident == "std" || path.segments[0].ident == "core")
                && path.segments[1].ident == "option"
                && path.segments[2].ident == "Option"
        {
            if let PathArguments::AngleBracketed(args) = &path.segments.last().unwrap().arguments {
                if let GenericArgument::Type(ty) = &args.args[0] {
                    return Some(ty);
                }
            }
        }
    }
    None
}

fn is_value(ty: &Type) -> Option<&Type> {
    if let Some(path) = ty_path(ty) {
        if path.segments.len() == 1 && path.segments[0].ident == "Value" {
            if let PathArguments::AngleBracketed(args) = &path.segments.last().unwrap().arguments {
                if let GenericArgument::Type(ty) = &args.args[0] {
                    return Some(ty);
                }
            }
        }
    }
    None
}
